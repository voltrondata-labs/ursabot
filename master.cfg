# -*- python -*-
# ex: set filetype=python:

import os
import pathlib
import toolz
import operator
import warnings

from buildbot.plugins import worker, steps, changes, util, reporters

from ursabot.hooks import UrsabotHook
from ursabot.utils import Config, ConfigError, Collection, startswith, any_of
from ursabot.changes import ChangeFilter
from ursabot.workers import DockerLatentWorker
from ursabot.secrets import SecretInPass
from ursabot.formatters import (MarkdownFormatter, BenchmarkCommentFormatter,
                                CrossbowCommentFormatter)
from ursabot.reporters import (GitHubStatusPush, GitHubReviewPush,
                               GitHubCommentPush, ZulipStatusPush)
from ursabot.schedulers import AnyBranchScheduler, TryScheduler, ForceScheduler
from ursabot.builders import (BuildFactory, Builder,
                              UrsabotTest, CrossbowTrigger,
                              ArrowCppTest, ArrowCppCudaTest,
                              ArrowCppBenchmark, ArrowPythonTest,
                              ArrowCppCondaTest, ArrowPythonCondaTest)

# Read ursabot configuration from .toml files, export URSABOT_ENV='test' to use
# test environment. These configurations are merged upon each other, the
# merging order is default.toml <- $env.toml <- local.toml <-.secrets.toml
env = os.environ.get('URSABOT_ENV', 'test')
conf = Config.load('default.toml', f'{env}.toml',
                   optionals=['local.toml', '.secrets.toml'])

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {
    'buildbotNetUsageData': None,
    'title': conf.title,
    'titleURL': conf.url,
    'buildbotURL': conf.url,
    'workers': [],
    'builders': [],
    'schedulers': [],
    'services': [],
    'change_source': [],
    'secretsProviders': [],
    'protocols': {'pb': {'port': conf.worker_port}},
    'db': {'db_url': conf.database_url},
    'www': {
        'port': conf.webui_port,
        'plugins': {
            'waterfall_view': {},
            'console_view': {},
            'grid_view': {}
        }
    }
}

# TODO(kszucs): create a Project abstraction to specify ursabot and arrow
# builders, schedulers, reporters in a cleaner fashion with support of enabling
# disabling each part

if conf.secrets.enabled:
    c['secretsProviders'].append(
        SecretInPass(
            passphrase=conf.secrets.get('passphrase'),
            dirname=pathlib.Path(conf.secrets.directory).expanduser()
        )
    )

############################## AUTHENTICATION ################################

if conf.github.auth.enabled:
    c['www']['auth'] = util.GitHubAuth(
        clientId=util.Interpolate(conf.github.auth.client_id),
        clientSecret=util.Interpolate(conf.github.auth.client_secret),
        apiVersion=4,
        getTeamsMembership=True
    )
    c['www']['authz'] = util.Authz(
        # 'admin' organization is unavalable on github so it is used to grant
        # access for specific users outside of allowed organizations
        allowRules=[
            util.AnyControlEndpointMatcher(role=org)
            for org in conf.github.auth.admin.orgs + ['admin']
        ],
        roleMatchers=[
            # github organization names becomes the roles assigned to the user
            util.RolesFromGroups(),
            # explicitly give roles to specific users
            util.RolesFromUsername(
                roles=['admin'],
                usernames=conf.github.auth.admin.users
            )
        ]
    )

################################ HOOKS ########################################

if conf.github.event_hook.enabled:
    c['www']['change_hook_dialects'] = {
        'github': {
            'class': UrsabotHook,
            'token': util.Interpolate(conf.github.token),
            'secret': util.Interpolate(conf.github.event_hook.secret),
            'debug': conf.github.event_hook.debug,
            'strict': True,
            'verify': True
        }
    }

################################ CHANGES ######################################
# The 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

if conf.changes.pb.enabled:
    c['change_source'].append(
        changes.PBChangeSource(
            port=conf.changes.pb.port,
            user=conf.changes.pb.user,
            passwd=conf.changes.pb.password
        )
    )

for key, project in conf.projects.items():
    try:
        owner, repo = project.name.split('/')
    except ValueError:
        raise ConfigError(f'project.{key}.name must be in `owner/repo`'
                          f' format instead of {project.name}')

    for source_name in project.change_sources:
        if source_name == 'git_poller':
            change = changes.GitPoller(
                project=project.name,
                repourl=project.repository,
                branch='master',
                pollInterval=180
            )
        elif source_name == 'pull_request_poller':
            change = changes.GitHubPullrequestPoller(
                owner=owner,
                repo=repo,
                token=util.Interpolate(conf.github.get('token')),
                branches=['master'],
                pollInterval=180,
                magic_link=True
            )
        else:
            raise ConfigError(f'Uknown change source name in project.{key}.'
                              f'change_sources: `{source_name}`')

        if project.enabled:
            c['change_source'].append(change)

################################ WORKERS ######################################
# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password. The same
# worker name and password must be configured on the worker.

workers = c['workers'] = Collection()

for worker in conf.workers:
    workers.append(
        DockerLatentWorker(
            f'{worker.name}-docker',
            arch=worker.arch,
            password=None,
            max_builds=worker.get('max_builds', 1),
            image=util.Property('docker_image'),
            docker_host=worker.docker.host,
            masterFQDN=worker.docker.get('masterFQDN'),
            autopull=worker.docker.get('autopull', True),
            alwaysPull=worker.docker.get('alwayspull', True),
            hostconfig=worker.docker.get('hostconfig', {}),
            missing_timeout=worker.docker.get('missing_timeout', 120)
        )
    )

################################ BUILDERS #####################################
# The 'builders' list defines the Builders, which tell Buildbot how to perform
# a build: what steps, and which workers can execute them.  Note that any
# particular build will only take place on one worker.

ursabot_builders = UrsabotTest.builders_for(
    workers.filter(arch='amd64')
)
crossbow_builders = CrossbowTrigger.builders_for(
    workers.filter(arch='amd64'),
    env={
        'GIT_COMMITTER_NAME': 'ursabot',
        'GIT_COMMITTER_EMAIL': 'ursabot@ci.ursalabs.org'
    }
)

arrow_tests = (
    ArrowCppTest.builders_for(workers) +
    ArrowPythonTest.builders_for(workers) +
    ArrowCppCondaTest.builders_for(workers) +
    ArrowPythonCondaTest.builders_for(workers)
)
arrow_cuda_tests = ArrowCppCudaTest.builders_for(workers)
arrow_benchmarks = ArrowCppBenchmark.builders_for(workers)

arrow_builders = (
    arrow_tests +
    arrow_cuda_tests +
    arrow_benchmarks
)

if conf.projects.ursabot.enabled:
    c['builders'].extend(ursabot_builders)

if conf.projects.arrow.enabled:
    c['builders'].extend(arrow_builders + crossbow_builders)

################################ SCHEDULERS ###################################
# Configure the Schedulers, which decide how to react to incoming changes.

if conf.schedulers['try'].enabled:
    c['schedulers'].append(
        TryScheduler(
            name='try',
            builders=c['builders'],
            port=conf.schedulers['try'].port,
            userpass=conf.schedulers['try'].userpass.items()
        )
    )

if conf.projects.ursabot.enabled:
    c['schedulers'].append(
        ForceScheduler(
            name='ursabot-force-scheduler',
            project=conf.projects.ursabot.name,
            repository=conf.projects.ursabot.repository,
            builders=ursabot_builders
        )
    )

if conf.projects.arrow.enabled:
    c['schedulers'].append(
        ForceScheduler(
            name='arrow-force-scheduler',
            project=conf.projects.arrow.name,
            repository=conf.projects.arrow.repository,
            builders=arrow_builders + crossbow_builders
        )
    )

ursabot_schedulers = [
    AnyBranchScheduler(
        name='ursabot',
        change_filter=ChangeFilter(
            project=conf.projects.ursabot.name,
        ),
        treeStableTimer=None,
        builders=ursabot_builders
    )
]

arrow_schedulers = [
    AnyBranchScheduler(
        name='arrow',
        change_filter=ChangeFilter(
            project=conf.projects.arrow.name,
            # see docstring of ursabot.hooks.GithubHook
            category=any_of(None, 'tag', 'pull'),
        ),
        treeStableTimer=None,
        builders=arrow_tests
    ),
    AnyBranchScheduler(
        name='arrow-benchmarks',
        change_filter=ChangeFilter(
            # ensure that benchmarks are not triggered on every commit of every
            # pull request, see docstring of ursabot.hooks.GithubHook
            project=conf.projects.arrow.name,
            category='comment',
            properties={'command': 'benchmark'}
        ),
        treeStableTimer=None,
        builders=arrow_benchmarks
    ),
    AnyBranchScheduler(
        name='crossbow-triggers',
        change_filter=ChangeFilter(
            # ensure that benchmarks are not triggered on every commit of every
            # pull request, see docstring of ursabot.hooks.GithubHook
            project=conf.projects.arrow.name,
            category='comment',
            properties={'command': 'crossbow'}
        ),
        treeStableTimer=None,
        builders=crossbow_builders
    )
]

if conf.projects.ursabot.enabled:
    c['schedulers'].extend(ursabot_schedulers)

if conf.projects.arrow.enabled:
    c['schedulers'].extend(arrow_schedulers)

################################ REPORTERS ####################################

# TODO(kszucs): consolitate the following similarly like the changes above

ursabot_reporters = []
arrow_reporters = []

if 'github_status' in conf.projects.ursabot.reporters:
    ursabot_reporters.append(
        GitHubStatusPush(
            token=util.Interpolate(conf.github.token),
            verbose=conf.reporters.github_status.debug,
            context=util.Interpolate('%(prop:buildername)s'),
            builders=ursabot_builders
        )
    )

if 'github_review' in conf.projects.ursabot.reporters:
    ursabot_reporters.append(
        GitHubReviewPush(
            token=util.Interpolate(conf.github.token),
            verbose=conf.reporters.github_review.debug,
            context=util.Interpolate('%(prop:buildername)s'),
            builders=ursabot_builders,
            dont_report_on={'started'}
        )
    )

if 'github_comment' in conf.projects.arrow.reporters:
    arrow_reporters.extend([
        GitHubCommentPush(
            name='BenchmarkCommentPush',
            token=util.Interpolate(conf.github.token),
            formatter=BenchmarkCommentFormatter(),
            builders=arrow_benchmarks,
            report_on={'failure', 'exception', 'cancelled', 'success'},
            verbose=True
        ),
        GitHubCommentPush(
            name='CrossbowCommentPush',
            token=util.Interpolate(conf.github.token),
            formatter=CrossbowCommentFormatter(
                crossbow_repo='ursa-labs/crossbow'
            ),
            builders=crossbow_builders,
            report_on={'failure', 'exception', 'cancelled', 'success'},
            verbose=True
        )
    ])

if 'zulip_status' in conf.projects.ursabot.reporters:
    ursabot_reporters.append(
        ZulipStatusPush(
            organization=conf.reporters.zulip_status.organization,
            bot=conf.reporters.zulip_status.bot,
            apikey=conf.reporters.zulip_status.apikey,
            stream=conf.reporters.zulip_status.stream,
            formatter=MarkdownFormatter(),
            builders=ursabot_builders,
            report_on={'failure', 'exception', 'cancelled'},
            verbose=True
        )
    )

if 'zulip_status' in conf.projects.arrow.reporters:
    arrow_reporters.append(
        ZulipStatusPush(
            organization=conf.reporters.zulip_status.organization,
            bot=conf.reporters.zulip_status.bot,
            apikey=conf.reporters.zulip_status.apikey,
            stream=conf.reporters.zulip_status.stream,
            formatter=MarkdownFormatter(),
            builders=arrow_builders + crossbow_builders,
            report_on={'failure', 'exception', 'cancelled'},
            verbose=True
        )
    )

if conf.projects.ursabot.enabled:
    c['services'].extend(ursabot_reporters)

if conf.projects.arrow.enabled:
    c['services'].extend(arrow_reporters)
